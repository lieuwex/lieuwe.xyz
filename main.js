// Generated by CoffeeScript 1.8.0
(function() {
  var app, compress, express, fs, gh, github, githubClient, githubDate, lastfm, lastfmClient, marked, minify, nowPlaying, onError, port, trackStream, _;

  _ = require("nimble");

  express = require("express");

  compress = require("compression");

  minify = require("express-minify");

  fs = require("fs");

  lastfm = require("lastfm").LastFmNode;

  github = require("github");

  marked = new require("marked");

  nowPlaying = null;

  app = express();

  app.set("view engine", "jade");

  app.use(compress({
    filter: function() {
      return true;
    }
  }));

  app.use(minify());

  app.use(express["static"](__dirname + "/public"));

  app.use("/css", express["static"](__dirname + "/css"));

  app.use(function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
    return next();
  });

  onError = function(err, req, res, next) {
    console.log(err.stack);
    return res.status(500).end("dat 500 tho.");
  };

  app.use(onError);

  lastfmClient = new lastfm({
    "api_key": "b68ffcb32c581066eff2eaa6443252d4",
    "secret": "92273fdb7205a5800f44555ddd6cc162"
  });

  githubClient = new github({
    version: "3.0.0"
  });

  trackStream = lastfmClient.stream("lieuwex");

  trackStream.on("nowPlaying", function(track) {
    return nowPlaying = track;
  });

  trackStream.on("stoppedPlaying", function() {
    return nowPlaying = null;
  });

  trackStream.start();

  githubDate = null;

  gh = function() {
    return githubClient.events.getFromUser({
      user: "lieuwex"
    }, function(e, r) {
      if (e == null) {
        return githubDate = r[0].created_at.substring(0, 10);
      }
    });
  };

  gh();

  setInterval(gh, 600000);

  app.get("/", function(req, res) {
    return fs.readdir("./posts", function(e, files) {
      if (e != null) {
        return onError(e, req, res);
      } else {
        files = _.filter(files, function(f) {
          var splitted;
          splitted = f.split(".");
          return splitted[splitted.length - 1] === "md";
        });
        return _.map(files, (function(file, cb) {
          return fs.stat("./posts/" + file, function(e, r) {
            return cb(e, {
              title: file.split(".")[0],
              creation: r.ctime.toISOString().substring(0, 10)
            });
          });
        }), function(e, r) {
          if (e != null) {
            return onError(e, req, res);
          } else {
            return res.render("index", {
              posts: r
            });
          }
        });
      }
    });
  });

  app.get("/me", function(req, res) {
    return res.render("me", {
      nowPlaying: nowPlaying,
      githubDate: githubDate
    });
  });

  app.get("/post/:post", function(req, res) {
    var name, path;
    name = unescape(req.params.post);
    path = "./posts/" + name + ".md";
    return fs.readFile(path, function(e, data) {
      if (e == null) {
        return fs.stat(path, function(e, stats) {
          if (typeof e === "function" ? e(onError(e, req, res)) : void 0) {

          } else {
            return res.render("post", {
              title: name,
              content: marked("" + data),
              creation: stats.ctime.toISOString().substring(0, 10)
            });
          }
        });
      } else if (e.code === "ENOENT") {
        return res.status(404).render("404");
      } else {
        return onError(e, req, res);
      }
    });
  });

  app.get("/projects", function(req, res) {
    return res.render("projects");
  });

  app.get("*", function(req, res) {
    return res.status(404).render("404");
  });

  port = process.env.PORT || 5000;

  app.listen(port, function() {
    return console.log("Running on port " + port);
  });

}).call(this);
